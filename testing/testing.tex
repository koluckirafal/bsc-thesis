\section{Realizacja testów i analiza ich wyników}

Po zmodyfikowaniu podzespołu należy sprawdzić, czy oryginalna funkcjonalność nie została w jakiś sposób naruszona oraz czy dodana funkcjonalność działa zgodnie z założeniami. W tym celu podzespół należy poddać procesowi weryfikacji. Można jej dokonać na różne sposoby, zaczynając od testów jednostkowych i integracyjnych, kończąc zaś na weryfikacji formalnej.
Weryfikacja formalna jest dokładniejsza ze względu na wykorzystywanie formalnych metod matematycznych, zajmuje jednak znacznie więcej czasu ze względu na konieczność opisania w formie matematycznej oczekiwanego zachowania układu. Wobec tego zostanie wykorzystana prostsza metoda testów jednostkowych - polega ona na opisaniu sekwencji sygnałów wejściowych testowanego komponentu oraz instrukcji pozwalających na interpretację stanów wyjściowych poprzez porównywanie ich do oczekiwanych wzorców.

\subsection{Analiza i porównanie przebiegów aktywności magistrali}

Wspomniane testy jednostkowe zostaną wykorzystane w kontekście tej pracy do sprawdzenia, czy dane są poprawnie odczytywane i zapisywane w pamięci Block RAM z wykorzystaniem zarówno klasycznych jak i potokowych cykli operacji na magistrali Wishbone. W tym celu każdy test wygeneruje sekwencję słów oraz adresów docelowych, które będą wykorzystywane zarówno do wytworzenia sygnałów wejściowych oraz jako wzorzec, do którego będzie porównywany stan końcowy testowanej pamięci.
Ze względu na to, iż obserwujemy wyłącznie stan zewnętrzny, do pamięci Block RAM dostanie dodany drugi port, który będzie pozwalał na dokonywanie operacji na pamięci z pominięciem interfejsu Wishbone.

\subsubsection{Implementacja testów jednostkowych dla peryferiów}

Testy zostały zrealizowane z użyciem języka Python, wykorzystując bibliotekę Cocotb, która umożliwia tworzenie środowiska testowego z użyciem składni języka Python zamiast w Verilogu. Pozwala to na integrację z bibliotekami ekosystemu języka Python, ułatwiając takie sprawy jak generowanie testowego zbioru danych.
Oprócz tego wykorzystane zostały biblioteki cocotb-test oraz cocotbext-wishbone. Cocotb-test integruje Cocotb z systemem testów automatycznych pytest, dzięki czemu napisane testy można uruchamiać z różnymi ustawieniami, co w połączeniu z parametryzacją samych testów umożliwia pokrycie różnych sposobów komunikacji z testowanym podzespołem na magistrali. Cocotbext-wishbone zaś implementuje funkcje do sterowania i monitorowania sygnałów na magistrali Wishbone, co pozwala zaoszczędzić czas poprzez wywoływanie gotowych funkcji realizujących operacje na magistrali zamiast poprzez ręczne sterowanie szyną.

\todo[inline]{LISTING: struktura katalogu test/}

Testowane peryferia, czyli pamięć SRAM oraz transceiver FIFO, zostały zainstancjonowane w minimalnym module LiteX, który na zewnątrz udostępnia wspólną magistralę Wishbone, drugi port pamięci SRAM, wyjście nadawczej kolejki FIFO oraz wejście odbiorczej kolejki FIFO. W ten sposób mamy dostęp do wszystkich sygnałów, które posłużą do wysterowania magistrali oraz komunikacji z peryferiami inną drogą, umożliwiając obserwowanie wpływu implementacji interfejsu Wishbone na komunikację z peryferiami. Jako że biblioteka Cocotb oczekuje opisu układu w języku Verilog, moduł LiteX jest eksportowany do pliku Verilog przed rozpoczęciem wykonywania testów.

\todo[inline]{LISTING: harness}

\subsubsection{Procedura wykonywania testów}
Zbiór testów jest wykonywany z użyciem komendy pytest, która jest częścią biblioteki o tej samej nazwie. Według deficji testów z pliku test.py generowana jest lista testów z różnymi kombinacjami parametrów według podanych przedziałów. Dzięki temu z czterech rodzajów testów (cykl klasyczny oraz wybrany cykl potokowych dla peryferium FIFO oraz modułu SRAM) otrzymano zbiór xxx testów, które zostają wykonywane po kolei. Po zakończeniu testów program pytest zwraca ich wyniki, które można zapisać również w formacie HTML. Umożliwia to wyfiltrowanie przypadków, dla których testy nie kończą się zgodnie z oczekiwaniami.

\todo[inline]{LISTING: struktura przykładowego testu}

\subsubsection{Porównanie wyników testów}

\todo[inline]{RYSUNEK: Przebiegi dla każdego rodzaju peryferiów i każdego rodzaju cykli}

\subsection{Testy wydajnościowe systemu jednoukładowego na symulatorze oraz na układzie FPGA}

Po zweryfikowaniu poprawności działania peryferiów kolejnym etapem jest przeprowadzenie testów wydajnościowych. Polegać one będą na wykonaniu testowego układu SoC, który zawierać będzie peryferium w wariancie zarówno zmodyfikowanym jak i oryginalnym. Na tym układzie uruchamiany będzie program, który będzie mierzyć prędkość operacji odczytu i zapisu zbioru danych w kolejności sekwencyjnej i losowej. Pozwoli to na zbadanie wpływu obsługi transferów potokowych na szybkość wykonywania operacji.

\subsubsection{Wykorzystane urządzenia}

Testy wydajnościowe były wykonywane w dwóch środowiskach: na zestawie deweloperskim Digilent Arty A7-35, zawierającym układ programowalnych bramek logicznych Artix-7 firmy Xilinx, oraz na symulatorze uruchomionym na średniej klasy komputerze klasy PC będącym pod kontrolą systemu operacyjnego Debian GNU/Linux. Symulator został automatycznie zbudowany poprzez framework LiteX z użyciem programu Verilator, zaś plik konfigurujący zachowanie układu FPGA (zwany bitstreamem) zbudowany został z wykorzystaniem zbioru narzędzi do syntezy Vivado firmy Xilinx.

\todo[inline]{RYSUNEK: zdjęcie arty-a7, output z symulatora lub inne jego przedstawienie}

\subsubsection{Testowy układ SoC i jego architektura}

Testowy system mikroprocesorowy składa się z procesora VexRiscv, czterech bloków pamięci SRAM, interfejsu UART do komunikacji między programem testowym a użytkownikiem oraz niewykorzystanych bloków interfejsu Ethernet i analizatora stanów logicznych.
Procesor VexRiscv został skonfigurowany z pamięcią podręczną danych wielkości XX kibibajtów oraz z obsługą architektury RV32I - obecność pamięci podręcznej jest szczególnie ważna, gdyż to właśnie na jej potrzeby procesor zawiera wsparcie dla transferów potokowych na magistrali Wishbone.
Z czterech pamięci SRAM dwa są w trybie tylko do odczytu - zawierać będą program rozruchowy oraz program testowy, które załadowane będą jako część bitstreamu dla układu FPGA.

\todo[inline]{RYSUNEK: schemat blokowy TestSoC}

\subsubsection{Program dla jednostki centralnej RISC-V badający szybkość operacji na pamięci}

Program testowy, zaimplementowany w języku C, testuje wybrany obszar pamięci poprzez zapisanie oraz odczytanie całego obszaru. Test ten jest wykonywany na dwa sposoby: dokonując operacji na kolejnych oraz losowy adresach.
Funkcje odpowiadające za przeprowadzenie testu są dostępne w ramach biblioteki libbase, będącej częścią frameworka LiteX - o ile funkcje można wywołać z poziomu konsoli programu rozruchowego, to program na etapie budowania zapisuje adres startowy oraz pojemność testowanej pamięci przekazany przez skrypt budujący gateware, pozwalając na automatyczne wykonanie testu w momencie załadowania bitstreamu na układ FPGA lub uruchomienia symulatora.
Dodatkową funkcjonalnością, dostępną w przypadku uruchomienia testu w symulacji, jest śledzenie wykonywania poprzez możliwość zapisywania "flagi" pod określonym wcześniej adresem - zawartość tego adresu jest potem zapisywana w pliku z przebiegami sygnałów emulowanego systemu, dzięki czemu można zbadać, jakie operacje na magistrali są wykonywane w danym fragmencie testu.

\todo[inline]{struktura programu, sposób kompilacji?}

\subsubsection{Wyniki testów wydajnościowych}

\todo[inline]{tabelki i wstępne spostrzeżenia}

%\subsection{CFU Plauground - w razie jakby nie udało się wycisnąć mininalnej ilości tekstu}

\subsection{Wnioski po realizacji testów}
