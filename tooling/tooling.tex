\section{Projektowanie, testowanie i uruchamianie układu SoC}

\subsection{Konstruowanie układu SoC z użyciem frameworka LiteX}

O ile układ SoC można zaprojektować w całości od podstaw, częstą praktyką jest wykorzystywanie gotowych komponentów, często napisanych przez zewnętrznych dostawców, w celu szybszego zaprojektowania układu spełniającego założenia projektowe.

Framework LiteX\cite{https://doi.org/10.48550/arxiv.2005.02506} dostarcza różnego rodzaju komponenty oraz narzędzia pozwalające na zbudowanie zarówno kompletnego układu SoC jak i bardziej specjalizowanych systemów w formie syntezowalnej logiki. W tym celu wykorzystuje bibliotekę Migen, która implementuje język opisu sprzętu w formie obiektów w języku Python. Dzięki temu możliwe jest opisanie logiki wykorzystując popularny język programowania wykorzystujący znajomą składnię, co zmniejsza barierę wejścia; oprócz tego można wykorzystać narzędzia z ekosystemu języka Python, dzięki czemu dostępne są między innymi większe możliwości parametryzacji logiki czy systemy do przeprowadzania testów automatycznych. Jednocześnie możliwe jest łączenie logiki napisanej w innych językach, co ułatwia wykorzystywanie komponentów nie będących częścią frameworka.

\todo[inline]{RYSUNEK: Budowa frameworka LiteX}

LiteX został wybrany jako podstawa tego projektu ze względu na dużą popularność tego frameworka w otwarto-źródłowych projektach wykorzystujących układy FPGA oraz z powodu doświadczenia autora niniejszej pracy nabytej poprzez wykorzystanie frameworka w swoich poprzednich projektach.

\subsection{Symulowanie układu z użyciem LiteX i Verilator}

LiteX zawiera modularne środowisko symulacji, które pozwala na symulację zaprojektowanego układu na podstawie opisanej w języku Migen logiki oraz parametrów dotyczących środowiska zewnętrznego. Możliwe jest dzięki temu przetestowanie układu oraz przeznaczonego na nie oprogramowania, przykładowo poprzez wykorzystanie wirtualnego interfejsu Ethernet do komunikacji. Ułatwia to usuwanie błędów z projektu układu jak i oprogramowania, zanim jeszcze układ zostanie zsyntetyzowany do formy bitstreamu dla układu FPGA na potrzeby dalszych testów.

\todo[inline]{LISTING: targetowanie symulatora}

W celu uruchomienia naszego systemu w symulatorze, układ musi być skonfigurowany do zbudowania z użyciem narzędzi symulacyjnych zamiast narzędziami syntezy dedykowanych konkretnemu układowi FPGA. W tym celu LiteX integruje obsługę programu Verilator w celu konwersji układu do kodu komputerowego w formie źródłowej. Ów program linkowany jest z tak zwanym "wrapperem", który łączy naszą logikę z dodatkowymi modułami, które symulują wybrane peryferia z użyciem zasobów systemu operacyjnego, na którym symulacja będzie wykonywana. W przypadku tego projektu będzie to interfejs szeregowy UART dostępny w formie standardowego strumienia wejścia/wyjścia oraz niewykorzystany interfejs Ethernet w formie wirtualnego interfejsu sieciowego w systemie hosta. W ten sposób symulacja układu nie różni się znacząco od wykonywania programu komputerowego, co ułatwia interakcję z programem wykonywanym w wirtualnym środowisku.

\todo[inline]{LISTING: definiowanie I/O z użyciem dicta sim_config przekazywanego do buildera}

W praktyce zbudowanie symulatora układu polega na podmianie wybranych peryferiów na modele, które są częściowo zaimplementowane w formie bibliotek dla symulatora Verilator, oraz na opisaniu wykorzystywanych modułów i sposobu dostępu do nich z poziomu systemu operacyjnego hosta.

\subsection{Testowanie logiki z użyciem biblioteki cocotb}

Standardową praktyką przy testowaniu układów logicznych jest pisanie tak zwanych test benchy, czyli skryptów wykorzystywanych do testowania logiki poprzez sterowanie sygnałami wejściowymi oraz porównywanie stanu sygnałów wyjściowych z oczekiwanymi wzorcami. Owe skrypty są zwykle pisane w tym samym języku, co testowany układ logiczny.

Ze względu na wykorzystywanie języka Python w tej pracy do zaprojektowania układu SoC, dobrym pomysłem jest użycie go również w celu testowania logiki. W tym celu wykorzystana została biblioteka cocotb, która pozwala na testowanie projektów zaimplementowanych w językach (System)Verilog i VHDL z użyciem skryptów napisanych w języku Python. Cocotb współpracuje z zarówno komercyjnymi jak i otwarto-źródłowymi symulatorami, dzięki czemu można tą bibliotekę wykorzystać w istniejących już środowiskach do projektowania układów logicznych.

\todo[inline]{LISTING: przykładowy test}

Jako, że ręczne wykonywanie transmisji na magistrali Wishbone oraz interpretowanie ich wyników będzie często powtarzaną operacją, w zamian użyta została biblioteka cocotbext-wishbone, która udostępnia dwa obiekty: monitora oraz sterownika. Sterownik odpowiada stronie inicjującej transfer na magistrali, zaś monitor obsługuje transfery w sposób identyczny do peryferiów, w stronę których transfery są wykonywane.

\todo[inline]{LISTING: cocotbext-wishbone - przykład użycia}

Wspomniana biblioteka cocotbext-wishbone została rozbudowana o przekazywanie i monitorowanie stanu dodatkowych sygnałów, które zostały uprzednio zdefiniowane w specyfikacji, a nie były wykorzystywane przy standardowych transferach. Pozwoliło to na kontrolowanie i monitorowanie stanu magistrali w testowanych układach po dokonaniu w nich zmian opisanych w następnym rozdziale.

\todo[inline]{LISTING: cocotbext-wishbone - diff z dodania sygnałów?}

\subsection{Wnioski związane z doborem narzędzi}